{
  parserClass="com.github.tth05.tethintellijplugin.syntax.TethParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Teth"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.tth05.tethintellijplugin.syntax.psi"
  psiImplPackage="com.github.tth05.tethintellijplugin.syntax.psi.impl"

  tokens=[
    COMMENT="regexp:(//[^\r\n]*)|(/*.*?\*/)"
  ]

  elementTypeHolderClass="com.github.tth05.tethintellijplugin.syntax.TethTypes"
  elementTypeClass="com.github.tth05.tethintellijplugin.syntax.TethElementType"
  tokenTypeClass="com.github.tth05.tethintellijplugin.syntax.TethTokenType"

  extends(".+BinaryExpression")=BinaryExpression
  extends(".+Expression")=Expression
  extends(".+Statement")=Statement

  name(".*Expression")="expression"
  name(".*Statement")="statement"

  consumeTokenMethod(".*Expression")="consumeTokenFast"
}

TethUnit ::= StatementList?

// Statements

StatementList ::= NL Statement (NL Statement)* NL

Statement ::=
      IfStatement
    | FunctionDeclarationStatement
    | StructDeclarationStatement
    | BlockStatement
    | ExpressionStatement

ExpressionStatement ::= Expression

BlockStatement ::= L_CURLY_PAREN StatementList? R_CURLY_PAREN

IfStatement ::= KEYWORD_IF ParenExpression Body

FunctionDeclarationStatement ::= KEYWORD_FN IDENTIFIER GenericParameters? FunctionDeclarationParameters Body
FunctionDeclarationParameters ::= L_PAREN (<<commaList (IDENTIFIER COLON Type)>>)* R_PAREN

StructDeclarationStatement ::=
    KEYWORD_STRUCT IDENTIFIER GenericParameters? NL L_CURLY_PAREN
        (NL (StructFieldDeclaration | FunctionDeclarationStatement))* NL
    R_CURLY_PAREN
StructFieldDeclaration ::= IDENTIFIER COLON Type

Body ::= BlockStatement | Statement
Arguments ::= L_PAREN <<commaList Expression>>? R_PAREN
GenericParameters ::= LESS <<commaList IDENTIFIER>> GREATER

// Type

Type ::= IDENTIFIER (LESS <<commaList Type>> GREATER)?

// Expressions

ParenExpression ::= L_PAREN Expression R_PAREN

MemberAccessExpression ::= Expression DOT MemberName
private MemberName ::= IDENTIFIER {
    name = "identifier"
}

FunctionInvocationExpression ::= Expression Arguments

Expression ::=
      AssignGroup
    | EqualityBinaryExpression
    | ConditionalGroup
    | AddGroup
    | MulGroup
    | ExpBinaryExpression
    | PrimaryGroup
    { name = "expression" }

private AssignGroup ::= AssignBinaryExpression
private ConditionalGroup ::= LogicalBinaryExpression | RelationalBinaryExpression
private AddGroup ::= AddBinaryExpression | SubtractBinaryExpression
private MulGroup ::= MultiplyBinaryExpression | DivideBinaryExpression
private PrimaryGroup ::= MemberAccessExpression | FunctionInvocationExpression | LiteralExpression | ParenExpression

// Binary expressions

fake BinaryExpression ::= Expression+ {
    methods=[left="Expression[0]" right="Expression[1]"]
}

AssignBinaryExpression ::= Expression EQUALS Expression {rightAssociative=true}
RelationalBinaryExpression ::= Expression (LESS | LESS_EQUALS | GREATER | GREATER_EQUALS) Expression
EqualityBinaryExpression ::= Expression (EQUALS_EQUALS | NOT_EQUALS) Expression
LogicalBinaryExpression ::= Expression (PIPE_PIPE | AMPERSAND_AMPERSAND) Expression
AddBinaryExpression ::= Expression NL PLUS NL Expression
SubtractBinaryExpression ::= Expression NL MINUS NL Expression
MultiplyBinaryExpression ::= Expression NL STAR NL Expression
DivideBinaryExpression ::= Expression NL SLASH NL Expression
ExpBinaryExpression ::= Expression NL CARET NL Expression

// Literals

LiteralExpression ::=
      LONG_LITERAL
    | DOUBLE_LITERAL
    | BooleanLiteral
    | IDENTIFIER
    | STRING_LITERAL
    {extends=Expression}

BooleanLiteral ::= KEYWORD_TRUE | KEYWORD_FALSE {extends=Expression}

// Helpers

private NL ::= NEWLINE*
private meta commaList ::= NL? <<p>> (NL? COMMA NL? <<p>>)*